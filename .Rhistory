install.packages("data.tree")
install.packages("data.tree")
install.packages("data.tree")
library(data.tree)
acme <- Node$new("Acme Inc.")
accounting <- acme$AddChild("Accounting")
software <- accounting$AddChild("New Software")
standards <- accounting$AddChild("New Accounting Standards")
research <- acme$AddChild("Research")
newProductLine <- research$AddChild("New Product Line")
newLabs <- research$AddChild("New Labs")
it <- acme$AddChild("IT")
outsource <- it$AddChild("Outsource")
agile <- it$AddChild("Go agile")
goToR <- it$AddChild("Switch to R")
print(acme)
acme <- Node$new("0")
as.character(1) <- acme$AddChild("1")
as.character(1)
acme
as.character(1) <- acme$AddChild(c(1,2,3))
acme$1
acme$as.character(1)$split <- c(1,1)
acme
acme$as.character(1)$split <- 3
acme
acme$name
acme$1
acme$children
acme$"1"
acme$"1"$split <- c(1,1)
acme
print(acme, "split")
matrix(,1,2)
l <- c(1,2,3)
k <- matrix(,1,2)
k[1][2]
k[1][2] <- l
a <- array(dim = c(2,2,3))
a
a[1,2, ] <- l
a
M1<- matrix(1:15,nrow=5)
M1[1,]
M1[1,]+M1[2,]
library(Matrix)
k <- list('abc','sadfa',2)
k
append(k,4,2)
append(k,4,-1)
matrixf(,2,3)
matrix(,2,3)
is.na(matrix(,2,3))
sum(is.na(matrix(,2,3)))
?array
array(,c(10,10))
Matrix(,10000,10000,sparse = TRUE)
tt <- Matrix(FALSE,10000,10000,sparse = TRUE)
tt
tt[2,4] <- TRUE
tt
tt[2,4] = tt[4,2] = tt[4,3]= TRUE
tt
sample(letters,n)
sample(letters,10)
matrix(c(0,1,0,1))
matrix(c(0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0),c(4,4))
m <- matrix(c(0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0),c(4,4))
library(igraph)
install(igraph)
install.packages("igraph")
library(igraph)
m <- matrix(c(0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0),c(4,4))
graph_from_adjacency_matrix(m, mode = 'undirected')
m_graph <- graph_from_adjacency_matrix(m, mode = 'undirected')
is_chordal(m_graph)
m1 <- matrix(c(0，1，0，1，0，1，0，1，0), c(3,3))
m1 <- matrix(c(0,1,0,1,0,1,0,1,0), c(3,3))
m1_graph <- graph_from_adjacency_matrix(m1, mode = 'undirected')
is_chordal(m1_graph)
l <- matrix(1:6,c(2,3))
length(l)
l
ncol(l)
empty <- c()
empty
empty <- c(empty,1)
empty
empty <- c(empty, 2)
empty
m
m_graph
adjacent_vertices(m_graph,1)
union(c(2,3),c(1,5))
intersect(c(2,3),c(1,5))
intersect(c(2,3),c(1,5))==0
intersect(c(2,3),c(1,5))=0
is.na(intersect(c(2,3),c(1,5)))
length(intersect(c(2,3),c(1,5)))
list(length = 10)
?list()
c(1:10)
is.element(c(1:5),c(3:9))
intersect(c(1:10),c(2,101),c(5:14))
setdiff(c(1:10),c(2,5))
setdiff(c(1:10),c(2,17))
setdiff(c(1:10),c(2:17))
?runif
runif(10)
runif(10)
d <- runif(10)
d^2
d ** 2
n <- 100000
dim <- 10
i <- 0
simulate <- c()
while (i < n){
point <- runif(p)
if (sqrt(sum(point ** 2)) <= 1){
simulate <- c(simulate, point)
i <- i + 1
}
}
n <- 100000
dim <- 10
i <- 0
simulate <- c()
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate <- c(simulate, point)
i <- i + 1
}
}
n <- 100
dim <- 10
i <- 0
simulate <- c()
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate <- c(simulate, point)
i <- i + 1
}
}
simulate
n <- 100
dim <- 10
i <- 0
simulate <- list()
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate <- append(simulate,point)
i <- i + 1
}
}
simulate
runif(10)
?list
l <- list
append(l, c(1,2))
?append
n <- 100
dim <- 10
i <- 0
simulate <- vector()
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate <- append(simulate,point)
i <- i + 1
}
}
simulate
?vector
n <- 100
dim <- 10
i <- 0
simulate <- vector(n)
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate[i + 1] <- point
i <- i + 1
}
}
l <- vector(length = 10)
l
n <- 100
dim <- 10
i <- 0
simulate <- vector(length = n)
while (i < n){
point <- runif(dim)
if (sqrt(sum(point ** 2)) <= 1){
simulate[i + 1] <- point
i <- i + 1
}
}
simulate
?array
a <- array(dim <- c(d,n))
a
d
n
n <- 100
p <- 10
a <- array(dim = c(p,n))
a
n <- 100
p <- 10
i <- 0
simulate <- array(dim <- c(n,p))
while (i < n){
point <- runif(p)
if (sqrt(sum(point ** 2)) <= 1){
simulate[i + 1,] <- point
i <- i + 1
}
}
simulate
simulate <- array(dim <- c(n,p))
simulate
simulate <- array(dim = c(n,p))
simulate
##Simulate points uniformly distributed in d-dimensional ball
n <- 100
p <- 10
i <- 0
simulate <- array(dim = c(n,p))
while (i < n){
point <- runif(p)
if (sqrt(sum(point ** 2)) <= 1){
simulate[i + 1,] <- point
i <- i + 1
}
}
simulate
##Simulate points uniformly distributed in d-dimensional ball
n <- 10000
p <- 10
i <- 0
simulate <- array(dim = c(n,p))
while (i < n){
point <- runif(p)
if (sqrt(sum(point ** 2)) <= 1){
simulate[i + 1,] <- point
i <- i + 1
}
}
simulate
n <- 10000
p <- 10
i <- 0
simulate <- array(dim = c(n, p))
while (i < n){
point <- runif(p)
if (0.5 < sqrt(sum(point ** 2)) < 1){
simulate[i+1,] <- point
i <- i+1
}
}
simulate
l <- runif(10)
l
norm(l)
?norm
n <- 10000
p <- 10
i <- 0
simulate <- array(dim = c(n, p))
while (i < n){
point <- runif(p)
point_norm <- sqrt(sum(point ** 2))
if (0.5 < point_norm & norm< 1){
simulate[i+1,] <- point
i <- i+1
}
}
simulate
n <- 10000
p <- 10
i <- 0
simulate <- array(dim = c(n, p))
while (i < n){
point <- runif(p)
point_norm <- sqrt(sum(point ** 2))
if (0.5 < point_norm & point_norm< 1){
simulate[i+1,] <- point
i <- i+1
}
}
simulate
rtorus
install.packages("alphashape3d")
simulate <- rtorus(n, upper_bound, lower_bound, ct= origin)
library(alphashape3d)
n <- 10000
upper_bound <- 1
lower_bound <- 0.5
origin <- c(0,0,0)
simulate <- rtorus(n, upper_bound, lower_bound, ct= origin)
?rtorus
library(rgl)
remove.packages("rgl")
install.packages("rgl")
library(rgl)
install.packages("XQuartz")
library(alphashape3d)
detach("package:rgl", unload = TRUE)
library(rgl)
?rtorus
library(alphashape3d)
n <- 10000
upper_bound <- 1
lower_bound <- 0.5
origin <- c(0,0,0)
simulate <- rtorus(n, upper_bound, lower_bound, ct= origin)
library(alphashape3d)
n <- 10000
upper_bound <- 1
lower_bound <- 0.5
origin <- c(0,0,0)
simulate <- rtorus(n, lower_bound, upper_bound, ct= origin)
simulate
dim(simulate)
typeof(simulate)
array(simulate,dim = c(n,3))
simulate_d <- cbind(array(points_torus,dim = c(n,3)),array(0,dim = c(n,p-3)))
points_torus <- rtorus(n, lower_bound, upper_bound, ct= origin)
simulate_d <- cbind(array(points_torus,dim = c(n,3)),array(0,dim = c(n,p-3)))
dim(simulate_d)
install.packages("pracma")
library(pracma)
randtho(10, type = 'orthogonal')
randortho(10, type = 'orthogonal')
randortho(10, type = 'orthonormal')
rand_ortho_matrix <- randortho(10, type = 'orthonormal')
simulate_after <- simulate_before %*% rand_ortho_matrix
simulate_before <- cbind(array(points_torus,dim = c(n,3)),array(0,dim = c(n,p-3)))
rand_ortho_matrix <- randortho(10, type = 'orthonormal')
simulate_after <- simulate_before %*% rand_ortho_matrix
simulate_after
det(rand_ortho_matrix)
##simulate a 3d-solid torus in p dimension by p*p orthogonal matrix transformation
library(alphashape3d)
?rtorus
library("rgl")
source('funcode.R')
source('erosion_new.R')
##Simulate a "eight-shape" region
n <- 100000
r <- 0.1
R <- 1
eight <- function(n,r,R){
sigma <- (R-r)/4
theta1 <- runif(n/2,min = 0, max = 2*pi)
theta2 <- runif(n/2, min = 0, max = 2*pi)
n1 <- rnorm(n/2,0,sigma^2)
n2 <- rnorm(n/2,0,sigma^2)
left_torus <- array(,dim = c(n/2,2))
left_torus[,1] <- ((R + r)/2 + n1)*cos(theta1)-0.55
left_torus[,2] <- ((R + r)/2 + n1)*sin(theta1)
right_torus <- array(,dim = c(n/2,2))
right_torus[,1] <- ((R + r)/2 + n2)*cos(theta2)+0.55
right_torus[,2] <- ((R + r)/2 + n2)*sin(theta2)
torus_data <- rbind(left_torus,right_torus)
return(torus_data)
}
eight_points1 <- eight(n,r,R)
#Visualization of the eight-shape object
plot(eight_points1)
eight_points2 <- eight(n,r,R)
array(eight_points1,dim = c(n,2))
simulate_before <- cbind(array(eight_points1,dim = c(n,2)),array(0,dim = c(n,1)))
rand_ortho_matrix <- randortho(p, type = 'orthonormal')
simulate_after <- simulate_before %*% rand_ortho_matrix
library("rgl")
source('funcode.R')
source('erosion_new.R')
setwd("~/")
setwd("~/Desktop/Research/HPD_topology")
library("rgl")
source('funcode.R')
source('erosion_new.R')
simulate_before <- cbind(array(eight_points1,dim = c(n,2)),array(0,dim = c(n,1)))
rand_ortho_matrix <- randortho(p, type = 'orthonormal')
simulate_after <- simulate_before %*% rand_ortho_matrix
simulate_before <- cbind(array(eight_points1,dim = c(n,2)),array(0,dim = c(n,1)))
rand_ortho_matrix <- randortho(3, type = 'orthonormal')
simulate_after <- simulate_before %*% rand_ortho_matrix
plot3d(simulate_after[,1],simulate_after[,2],simulate_after[,3])
simulate_before1 <- cbind(array(eight_points1,dim = c(n,2)),array(0,dim = c(n,1)))
simulate_before2 <- cbind(array(eight_points2,dim = c(n,2)),array(0,dim = c(n,1)))
rand_ortho_matrix <- randortho(3, type = 'orthonormal')
simulate_after1 <- simulate_before1 %*% rand_ortho_matrix
plot3d(simulate_after[,1],simulate_after[,2],simulate_after[,3])
simulate_after2 <- simulate_before2 %*% rand_ortho_matrix
train.sim <- simulate_after1
test.sim <- simulate_after1
conv_training <- convert.marginal(train.sim,train.sim)
conv_testing <- convert.marginal(train.sim,test.sim)
vector_tau = seq(0.5,0.01,len=10)
alpha = 0.05
out=cred.est2(test=conv_testing,train.sim=train.sim,train=conv_training,tau=vector_tau,alpha=alpha,p.alpha=0.95)
k <- out$n.tree
HPD <- out$cre.set
all_cells <- out$uni_space
complement <- all_cells[(length(HPD)+1):k]
e <- erosion1(HPD, complement)
all_graph <- e[[1]]
HPD_vertices <- e[[2]][[1]]
HPD
k
e <- erosion1(HPD, complement)
all_graph <- e[[1]]
HPD_vertices <- e[[2]][[1]]
HPD_vertices
HPD
e
HPD
library("rgl")
source('funcode.R')
source('erosion_new.R')
##test for torus
#Simulate points in a 3d torus, points are more denser around the circle in the middle
n <- 100000
r <- 0.75
R <- 1
torus_data <- function(n,r,R){
sigma <- (R-r)/4  #so that the boudnary is at 3 sigma
theta1 <- runif(n,min = 0, max = 2*pi)
theta2 <- runif(n, min = 0, max = 2*pi)
norm_points <- abs(rnorm(n, mean = 0, sd = sigma^2))
x <- ((r + R)/2 - norm_points*cos(theta2))*cos(theta1)
y <- ((r + R)/2 - norm_points*cos(theta2))*sin(theta1)
z <- sin(theta2)*norm_points
torus_data <- array(data = NA,dim = c(n,3))
torus_data[,1] <- x
torus_data[,2] <- y
torus_data[,3] <- z
return (torus_data)
}
torus_points1 <- torus_data(n,r,R)
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
torus_points2 <- torus_data(n,r,R)
library("rgl")
source('funcode.R')
source('erosion_new.R')
##test for torus
#Simulate points in a 3d torus, points are more denser around the circle in the middle
n <- 100000
r <- 0.3
R <- 1
torus_data <- function(n,r,R){
sigma <- (R-r)/4  #so that the boudnary is at 3 sigma
theta1 <- runif(n,min = 0, max = 2*pi)
theta2 <- runif(n, min = 0, max = 2*pi)
norm_points <- abs(rnorm(n, mean = 0, sd = sigma^2))
x <- ((r + R)/2 - norm_points*cos(theta2))*cos(theta1)
y <- ((r + R)/2 - norm_points*cos(theta2))*sin(theta1)
z <- sin(theta2)*norm_points
torus_data <- array(data = NA,dim = c(n,3))
torus_data[,1] <- x
torus_data[,2] <- y
torus_data[,3] <- z
return (torus_data)
}
torus_points1 <- torus_data(n,r,R)
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
torus_points2 <- torus_data(n,r,R)
dev.new()
p
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
library("rgl")
source('funcode.R')
source('erosion_new.R')
##test for torus
#Simulate points in a 3d torus, points are more denser around the circle in the middle
n <- 100000
r <- 0.3
R <- 1
torus_data <- function(n,r,R){
sigma <- (R-r)/4  #so that the boudnary is at 3 sigma
theta1 <- runif(n,min = 0, max = 2*pi)
theta2 <- runif(n, min = 0, max = 2*pi)
norm_points <- abs(rnorm(n, mean = 0, sd = sigma^2))
x <- ((r + R)/2 - norm_points*cos(theta2))*cos(theta1)
y <- ((r + R)/2 - norm_points*cos(theta2))*sin(theta1)
z <- sin(theta2)*norm_points
torus_data <- array(data = NA,dim = c(n,3))
torus_data[,1] <- x
torus_data[,2] <- y
torus_data[,3] <- z
return (torus_data)
}
torus_points1 <- torus_data(n,r,R)
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
torus_points2 <- torus_data(n,r,R)
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
dev.off
#Interactive plot of the simulated torus
plot3d(torus_points1[,1],torus_points1[,2],torus_points1[,3],xlim = c(-1.3,1.3),ylim = c(-1.3,1.3), zlim = c(-1.3,1.3),xlab = 'x', ylab = 'y',zlab = 'z')
